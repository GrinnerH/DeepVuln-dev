下面是一份可直接保存为项目设计笔记 / 项目 README / 论文方法附录草稿的完整总结。
它的目标是：任何一个新加入的人（或你在新会话中）只看这一份，就能准确理解 DeepVuln 2.0 在“做什么、为什么这样做、现在做到哪一步、接下来怎么做”。

---
DeepVuln 2.0
基于漏洞示例的失败驱动语义建模（Failure-Driven Semantic Modeling）

---
一、我们在解决什么问题（Problem Statement）
核心问题一句话版：
CodeQL 并不是不会发现漏洞，而是它不知道“项目语义”；
我们要做的不是替换 CodeQL，而是用真实漏洞教会它项目是如何“认为自己是安全的”。
背景事实
- CodeQL 擅长：
  - AST / CFG / Dominance / 类型系统
  - 标准库函数（如 strcpy、memcpy）的机制级建模
- CodeQL 不擅长：
  - 项目级约定（宏、字段含义、设计假设）
  - 隐式语义（“这个字段来自文件，不可信”）
  - 框架 idiom（自定义 wrapper、安全约定）
典型漏报场景（以 GPAC / CVE-2024-22749 为例）
strcpy(entry->compressor_name, udesc->compressor_name);
- sink：strcpy ✔（已建模）
- dest：固定大小数组 ✔
- src：来自 MP4 文件元数据 ✘（语义缺失）
- 没有显式长度约束 → CodeQL 无法完成 size 证明 → 放弃报警

---
二、方法论总览（Method Overview）
方法名称（内部）
Iterative Semantic Modeling from Vulnerability Exemplars
（基于漏洞示例的迭代语义建模）
核心哲学：逻辑-语义解耦（Logic–Semantic Decoupling）
暂时无法在飞书文档外展示此内容
LLM 不参与最终漏洞判定，只提供“语义候选”；
CodeQL 决定这些语义是否在逻辑上成立。

---
三、总体工作流（High-Level Workflow）
整体被拆为 Step A（物料准备） + Step B（语义学习闭环） + Step C（目标扫描）

---
Step A：Seed 物料准备（完全自动化，脚本完成）
目标：一次性把“可复现实验环境”准备好
输入
- seeds/seed_cases.json
（如 GPAC / CVE-2024-22749）
自动化内容
- clone / update repo
- checkout 到 vuln commit
- codeql database create（支持 build_command）
- 固化 baseline 查询路径
输出（写入 workspace）
- seed_manifest.json，包含：
  - repo_path
  - db_path
  - vulnerable_file
  - target_function
  - baseline_query_path
⚠️ 重要原则：
LangGraph 中的节点 不负责 clone / build / 建库，只消费 manifest。

---
Step B：语义学习闭环（核心创新）
这是一个显式体现在 Graph 拓扑上的 3 节点闭环：
诊断 → 合成 → 评估 → (继续 | 收敛 | 终止)
B1 · diagnose_vulnerability_gap
基线失败归因
做什么：
1. 使用 MCP CodeQL 客户端跑 baseline 查询
2. 读取漏洞函数源码（精确到函数）
3. 构造“失败驱动”的 Prompt 让 LLM 回答：
LLM 必须回答：
- GapKind（缺失的是哪类语义）
  - capacity_semantics_missing
  - length_semantics_missing
  - guard_semantics_missing
  - logic_mismatch
- 可证伪假设（为什么 CodeQL 会放弃判定）
- 证据引用（源码片段 / SARIF / CFG slice）
输出：
active_diagnosis = {
  "gap_kind": "...",
  "hypothesis": "...",
  "supporting_evidence_refs": [...]
}

---
B2 · synthesize_semantic_model
语义补齐包生成
做什么：
- 基于 active_diagnosis
- 让 LLM 生成 ProjectSemantics.qll
  - 例如：哪些字段是“不受限输入”
  - 哪些宏代表 buffer capacity
- 写入版本化路径：
workspace/semantic_packs/iter_01/ProjectSemantics.qll
输出：
active_semantic_artifact = {
  "semantic_pack_path": "..."
}

---
B3 · evaluate_modeling_success
可执行验证 + 收敛判定
做什么：
1. codeql query compile（验证语义包是否合法）
2. 在 seed DB 上重新运行查询
3. 计算：
  - compile_ok
  - seed_hit_rate
4. 做出明确决策：
active_decision = {
  "outcome": "continue | converged | halt",
  "rationale": "..."
}
并生成一条 ModelingRecord（论文级实验数据）：
{
  "iteration_index": 1,
  "diagnosis": {...},
  "semantic_artifact": {...},
  "metrics": {...},
  "decision": {...}
}

---
Step C：目标扫描（非本阶段重点）
- 使用 最终收敛的语义包
- 对目标仓库运行扫描
- 输出 SARIF / findings

---
四、系统架构（Implementation Architecture）
1️⃣ LangGraph 拓扑（Flat Graph，无 Subgraph）
- 7 个宏节点
- Stage B 为 3 节点闭环
- 使用 conditional_edges 控制循环
设计原则：
- 循环体现在 Graph 上，而不是藏在 node 内
- 每个节点是“单一责任 + 可调试”

---
2️⃣ 全局 State 设计（DeepVulnState）
关键设计点：
- 使用 Annotated[..., operator.add] 累积建模历史
- 明确区分：
  - 活动状态（active_*）
  - 历史轨迹（modeling_history）
  - 最终资产（best_semantic_pack_path）
State 能直接用于：
- 论文画“语义演化曲线”
- Debug LLM 行为
- 实验可复现

---
3️⃣ CodeQL 交互统一入口（MCP Client）
- 唯一 CodeQL 接口：CodeQLMCPClient
- 封装：
  - database create
  - database analyze
  - query compile
- 吸收旧版 tools 中的健壮逻辑：
  - finalize / 重建
  - build 失败清理
- 后续可无痛替换为真正 MCP server

---
4️⃣ LLM 调用规范（LangGraph v1.0）
- 不使用旧 AgentExecutor
- 使用：
  - Runnable.invoke()
  - .with_structured_output(PydanticModel)
- 结构化输出 = 强类型 State 更新
- RAG（RAGFlow MCP）：
  - 按需调用
  - 引用写入 docs_citation_refs
  - 非核心实现点

---
s一句话总结
DeepVuln 2.0 是一个：
通过真实漏洞示例，分析静态分析失败原因，
并用 LLM 生成“项目语义补齐包”，
由 CodeQL 严格验证其有效性的失败驱动语义学习系统。